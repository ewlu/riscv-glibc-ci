name: Run checks

on:
  workflow_call:
    inputs:
      patch_name:
        required: true
        type: string
      baseline_hash: # Baseline glibc
        required: true
        type: string

jobs:
  download_patches:
    runs-on: ubuntu-22.04
    defaults:
      run:
        working-directory: ./
    steps:
      - uses: actions/checkout@v3

      - name: Setup env
        uses: ./.github/actions/common/setup-env
        with:
          free_up_space: false

      - name: Download patch urls artifact
        uses: actions/download-artifact@v3
        with:
          name: patch_urls
          path: ./

      - name: Download patchworks urls artifact
        uses: actions/download-artifact@v3
        with:
          name: patchworks_metadata_files
          path: ./

      - name: Extract patch urls
        run: |
          unzip patch_files.zip

      - name: Extract patchworks metadata
        run: |
          unzip patchworks_metadata_files.zip

      - name: Create patches dir
        run: |
          mkdir patches

      - name: Download patches from urls
        run: |
          scripts/download_patches.sh -p ${{ inputs.patch_name }}
          mv patchworks_metadata/${{ inputs.patch_name }} patches/

      - name: Zip patches
        run: |
          zip -r ${{ inputs.patch_name }}-downloaded-patches.zip patches

      - name: Upload patches artifact
        uses: actions/upload-artifact@v3
        with:
          name: ${{ inputs.patch_name }}-downloaded-patches
          path: |
            ./${{ inputs.patch_name }}-downloaded-patches.zip
          retention-days: 90

  create-issue:
    needs: [download_patches]
    runs-on: ubuntu-22.04
    permissions:
      issues: write
    defaults:
      run:
        working-directory: ./
    steps:
      - uses: actions/checkout@v3

      - name: Setup env
        uses: ./.github/actions/common/setup-env
        with:
          free_up_space: false

      - name: Download patches artifact
        uses: actions/download-artifact@v3
        with:
          name: ${{ inputs.patch_name }}-downloaded-patches
          path: ./

      - name: Extract patches
        run: |
          unzip ${{ inputs.patch_name }}-downloaded-patches.zip

      - name: Build initial issue
        run: |
          printf "## Precommit CI Run information\n" > issue.md
          printf "Logs can be found in the associated Github Actions run: https://github.com/ewlu/riscv-glibc-ci/actions/runs/${{ github.run_id }}\n" >> issue.md
          printf "## Patch information\n" >> issue.md
          head -n 3 patches/${{ inputs.patch_name }} >> issue.md
          # Issue closer depends on patch id
          printf "Patch id: %d\n" $(tail -n 1 patches/${{ inputs.patch_name }}) >> issue.md
          echo "If you have any questions or encounter any issues which may seem like false-positives, please contact us at patchworks-ci@rivosinc.com" >> issue.md
          cat issue.md

      - name: Create initial issue
        uses: peter-evans/create-issue-from-file@v4
        id: create-issue
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          content-filepath: ./issue.md
          title: 'Patch Status ${{ inputs.patch_name }}'

      - name: Build additional info link
        id: link
        run: |
          sleep 1
          curl -L -H "Accept: application/vnd.github+json" -H "Authorization: Token ${{ secrets.GITHUB_TOKEN }}" -H "X-GitHub-Api-Version: 2022-11-28" https://api.github.com/repos/ewlu/riscv-glibc-ci/issues/${{ steps.create-issue.outputs.issue-number }} | jq '.id' > issue_body_comment_id.txt
          export LINK=https://github.com/ewlu/riscv-glibc-ci/issues/${{ steps.create-issue.outputs.issue-number }}#issue-$(cat issue_body_comment_id.txt)
          echo $LINK
          echo "additional=$LINK" >> $GITHUB_OUTPUT


      # - name: Make lint pending comment
      #   run: |
      #     echo "## Lint Status" > lint_pending.md
      #     echo "Lint pending" >> lint_pending.md

      # - name: Create lint report comment
      #   uses: peter-evans/create-or-update-comment@v3
      #   id: lint-comment
      #   env:
      #     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      #   with:
      #     issue-number: ${{ steps.create-issue.outputs.issue-number }}
      #     body-path: riscv-gnu-toolchain/lint_pending.md
      #     edit-mode: replace

      - name: Create apply pending report
        run: |
          python scripts/generate_apply_report.py -patch ${{ inputs.patch_name }} -bhash ${{ inputs.baseline_hash }} -bstatus pending -o comment.md
          printf "\n[Additional information](${{ steps.link.outputs.additional }})\n" >> comment.md

      - name: Create apply report comment
        uses: peter-evans/create-or-update-comment@v3
        id: apply-comment
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          issue-number: ${{ steps.create-issue.outputs.issue-number }}
          body-path: ./comment.md
          edit-mode: replace

    outputs:
      issue_num: ${{ steps.create-issue.outputs.issue-number }}
      # lint_comment_id: ${{ steps.lint-comment.outputs.comment-id }}
      apply_comment_id: ${{ steps.apply-comment.outputs.comment-id }}
      additional_info: ${{ steps.link.outputs.additional }}

  # build_test:
  #   # needs: [download_patches, create-issue, apply]
  #   needs: [download_patches, create-issue]
  #   if: ${{ needs.apply.outputs.early_exit != 'true' }}
  #   uses: ./.github/workflows/build-target.yaml
  #   with:
  #     patch_name: ${{ inputs.patch_name }}
  #     baseline_hash: ${{ inputs.baseline_hash }}
  #     build_only: ${{ needs.apply.outputs.build_only }}
  #     issue_num: ${{ needs.create-issue.outputs.issue_num }}
  #     apply_comment_id: ${{ needs.create-issue.outputs.apply_comment_id }}
  #     additional_info: ${{ needs.create-issue.outputs.additional_info }}
  #   secrets: inherit
  
  apply:
    needs: [download_patches, create-issue]
    runs-on: ubuntu-22.04
    environment: production
    defaults:
      run:
        working-directory: ./glibc
    steps:
      - uses: actions/checkout@v3

      - name: Setup env
        uses: ./.github/actions/common/setup-env
        with:
          free_up_space: false

      - name: Bump pyopenssl and crypto
        run: |
          sudo apt remove python3-pip
          wget https://bootstrap.pypa.io/get-pip.py
          sudo python3 get-pip.py
          pip install -U pyopenssl cryptography
          pip install pygithub==1.59.1 requests

      - name: Download patches artifact
        uses: actions/download-artifact@v3
        with:
          name: ${{ inputs.patch_name }}-downloaded-patches
          path: ./glibc

      - name: Extract patches
        run: |
          unzip ${{ inputs.patch_name }}-downloaded-patches.zip

      - name: Apply patches to baseline
        id: apply-baseline
        run: |
          git checkout master
          git pull
          git checkout ${{ inputs.baseline_hash }}
          git config user.name "GitHub Actions Bot"
          git config user.email "<>"
          git am ./patches/*.patch --whitespace=fix -q --3way --empty=drop &> out || true
          cat out
          if [[ $(cat out | wc -l) != 0 ]]; then
            git am --show-current-patch=diff
            echo "Failed to apply patch cleanly to tip of tree"
            git am --show-current-patch=diff &>> out
            git am --abort
            echo "apply_baseline=false" >> $GITHUB_OUTPUT
          else
            echo "apply_baseline=true" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true

      - name: Check patch applied
        id: early-exit
        run: |
          if [[ $(cat ./out | wc -l) != 0 ]];
          then 
            python ../scripts/generate_apply_report.py -patch ${{ inputs.patch_name }} -bhash ${{ inputs.baseline_hash }} -bstatus "false" -o comment.md
            echo "early_exit=true" >> $GITHUB_OUTPUT
          else
            python ../scripts/generate_apply_report.py -patch ${{ inputs.patch_name }} -bhash ${{ inputs.baseline_hash }} -bstatus "true" -o comment.md
            echo "early_exit=false" >> $GITHUB_OUTPUT
          fi
          head -c 65000 comment.md > trimmed_comment.md
          if [ $(cat trimmed_comment.md | wc -l) -ne $(cat comment.md | wc -l) ]; then printf "\n\`\`\`\nComment text has been trimmed. Please check logs for the untrimmed comment." >> trimmed_comment.md; fi
          printf "\n[Additional information](${{ inputs.additional_info }})\n" >> trimmed_comment.md

      - name: Update apply report comment
        uses: peter-evans/create-or-update-comment@v3
        id: apply-comment
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          comment-id: ${{ needs.create-issue.outputs.apply_comment_id }}
          body-path: glibc/trimmed_comment.md
          edit-mode: replace

      - name: Add apply-failure label if patch failed to apply anywhere
        if: ${{ steps.apply-baseline.outputs.apply_baseline == 'false' }}
        uses: actions/github-script@v6
        with:
          script: |
            github.rest.issues.addLabels({
              issue_number: ${{ needs.create-issue.outputs.issue_num }},
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['apply-failure']
            })

      - name: Output the hash after the patch has been applied
        id: new-glibc-hash
        if: ${{ steps.apply-baseline.outputs.apply_baseline == 'true' }}
        run: |
          export PATCH_APPLIED_GLIBCHASH=$(git rev-parse HEAD)
          echo $PATCH_APPLIED_GLIBCHASH
          echo "patch_applied_glibchash=$PATCH_APPLIED_GLIBCHASH" >> $GITHUB_OUTPUT

    outputs:
      early_exit: ${{ steps.early-exit.outputs.early_exit }}
      patch_applied_glibchash: ${{ steps.new-glibc-hash.outputs.patch_applied_glibchash }}


  initialize-comments:
    runs-on: ubuntu-22.04
    needs: [download_patches, create-issue, apply]
    if: ${{ needs.apply.outputs.early_exit != 'true' }}
    defaults:
      run:
        working-directory: ./
    steps:
      - uses: actions/checkout@v3

      - name: Setup env
        uses: ./.github/actions/common/setup-env
        with:
          free_up_space: false

      - name: Download patches artifact
        uses: actions/download-artifact@v3
        with:
          name: ${{ inputs.patch_name }}-downloaded-patches
          path: ./

      - name: Extract patches
        run: |
          unzip ${{ inputs.patch_name }}-downloaded-patches.zip

      - name: Create build pending comment
        run: |
          echo "## Build Many Glibcs Status" > build_pending_comment.md
          printf "\n[Additional information](${{ needs.create-issue.outputs.additional_info }})\n" >> build_pending_comment.md

      - name: Create build report comment
        uses: peter-evans/create-or-update-comment@v3
        id: build-comment
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          issue-number: ${{ needs.create-issue.outputs.issue_num }}
          body-path: ./build_pending_comment.md
          edit-mode: replace

      - name: Create build pending comment
        run: |
          echo "## Testing Glibcs Status" > test_pending_comment.md
          printf "\n[Additional information](${{ needs.create-issue.outputs.additional_info }})\n" >> test_pending_comment.md

      - name: Create build report comment
        uses: peter-evans/create-or-update-comment@v3
        id: test-comment
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          issue-number: ${{ needs.create-issue.outputs.issue_num }}
          body-path: ./test_pending_comment.md
          edit-mode: replace

    outputs:
      build_glibc_comment_id: ${{ steps.build-comment.outputs.comment-id }}
      test_glibc_comment_id: ${{ steps.test-comment.outputs.comment-id }}

  # build-many-glibcs: 
  #   needs: [initialize-comments]
  #   uses: ./.github/workflows/build-glibcs.yaml
  #   with:
  #     patch_name: ${{ inputs.patch_name }}
  #     baseline_hash: ${{ inputs.baseline_hash }}
  #     patch_applied_glibchash: ${{ inputs.patch_applied_glibchash }}
  #     issue_num: ${{ needs.create-issue.outputs.issue_num }}
  #     build_comment_id: ${{ needs.initialize-comments.outputs.build_glibc_comment_id }}
  #     run_on_self_hosted: false
  #     tot_hash: ${{ inputs.tot_hash }}
  #     additional_info: ${{ needs.create-issue.outputs.additional_info }}
  #   secrets: inherit


  test-glibc-linux-baseline:
    # needs: [initialize-comments,make-rootfs-baseline]
    needs: [download_patches, create-issue, initialize-comments]
    uses: ./.github/workflows/test-regression.yaml
    strategy:
      fail-fast: false
      matrix:
        target:
          [
            # rv32gc-ilp32d,
            rv64gc-lp64d,
          ]
    with:
      patch_name: 
      glibchash: ${{ inputs.baseline_hash }}
      target: ${{ matrix.target }}
      issue_num: ${{ needs.create-issue.outputs.issue_num }}
      test_comment_id: ${{ needs.initialize-comments.outputs.test_comment_id }}
      additional_info: ${{ needs.create-issue.outputs.additional_info }}
      target_type: 'baseline'
    secrets: inherit

  test-glibc-linux-applied:
    needs: [download_patches, create-issue, initialize-comments, apply]
    # needs: [initialize-comments]
    uses: ./.github/workflows/test-regression.yaml
    strategy:
      fail-fast: false
      matrix:
        target:
          [
            # rv32gc-ilp32d,
            rv64gc-lp64d,
          ]
    with:
      patch_name: ${{ inputs.patch_name }}
      glibchash: ${{ needs.apply.outputs.patch_applied_glibchash }}
      target: ${{ matrix.target }}
      issue_num: ${{ needs.create-issue.outputs.issue_num }}
      test_comment_id: ${{ needs.initialize-comments.outputs.test_comment_id }}
      additional_info: ${{ needs.create-issue.outputs.additional_info }}
      target_type: 'applied'
    secrets: inherit


  summarize:
    if: "!cancelled()" # Generate github issues even when some (or all) targets fail to build
    needs: [apply,initialize-comments,test-glibc-linux-applied,test-glibc-linux-baseline]
    permissions:
      issues: write
    uses: ./.github/workflows/generate-precommit-summary.yaml
    with:
      patch_name: ${{ inputs.patch_name }}
      baseline_hash: ${{ inputs.baseline_hash }}
      patch_applied_glibchash: ${{ inputs.patch_applied_glibchash }}
      issue_num: ${{ needs.create-issue.outputs.issue_num }}
      build_comment_id: ${{ needs.initialize-comments.outputs.build_comment_id }}
      test_comment_id: ${{ needs.initialize-comments.outputs.test_comment_id }}
      additional_info: ${{ needs.create-issue.outputs.additional_info }}
    secrets: inherit
